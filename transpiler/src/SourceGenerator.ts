import {isNullOrUndefined} from "util"
import ASTVisitor, {Binding} from "./ASTVisitor"
import * as Node from "./nodes"
import {hasParenthesis} from "./ParensUtil"
import {Syntax} from "./syntax"
import DocumentBuilder from "./DocumentBuilder"

/**
 * Source generator to transform valid AST back into ECMAScript
 * JS does not support overloading, so the visit methods need different names.
 *
 * Usage
 *
 * ```
 *  const generator = new SourceGenerator();
 *  const script = generator.toSource(ast);
 *  console.info('-------')
 *  console.info(script)
 * ```
 */
export default class SourceGeneratorWithBuilder {
    /**
     * Convert ASTNode back into sourcecode representation
     *
     * @param node
     */
    toSource(node: Node.Module): string {
        this.decorate(node, null, "")

        const visitor = new ExplicitASTNodeVisitor()
        visitor.visitModule(node)
        return visitor.buffer
    }

    /**
     * Decorate node with new properties `__path__` and `__parent__`
     * to provide additional information during source transpiling
     *
     * This will create circular dependencies and will mess with tests
     * if the `Util.toJson` is not used.
     *
     * @param node the node to decorate
     * @param parent the parent node
     * @param path the current path in the object graph
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    decorate(node: any, parent: any | null, path: string): void {
        if (node == null) {
            return
        }
        const keys = Object.getOwnPropertyNames(node)
        for (const key in keys) {
            const name = keys[key]
            if (name.startsWith("__")) {
                continue
            } else if (name == "type") {
                if (path === "") {
                    path = node[name]
                } else {
                    path += "." + node[name]
                }
                node["__parent__"] = parent
            } else if (typeof node[name] === "object") {
                this.decorate(node[name], node, path)
            }
        }
    }
}

class ExplicitASTNodeVisitor extends ASTVisitor<void> {
    private builder: DocumentBuilder

    constructor() {
        super()
        this.builder = new DocumentBuilder()
    }

    get buffer(): string {
        return this.builder.toSource()
    }

    private write(txt: string, newline = false): void {
        this.builder.write(txt)
        if (newline) {
            this.builder.write("\n")
        }
    }

    private writeNewLine() {
        this.write("\n", false)
    }

    private writeIndend() {
        this.builder.indent()
    }

    private writeConditional(condition: boolean, txt: string, newline = false): void {
        if (condition) {
            this.write(txt, newline)
        }
    }

    visitModule(node: Node.Module): void {
        // this.write("// Generated by Delven transpiler ver 0.0.3", false)
        // this.writeNewLine()
        for (const stm of node.body) {
            this.visitStatement(stm)
        }
        this.writeNewLine()
    }

    visitStatement(statement: Node.Declaration | Node.Statement) {
        // block statements are handled differently
        let prolog = true
        let parent = statement.__parent__
        let name = statement.__name__

        switch (statement.type) {
            case Syntax.IfStatement: {
                if (name === "alternate") {
                    prolog = false
                }
                break
            }

            case Syntax.ClassDeclaration: {
                switch (parent.type) {
                    case Syntax.ExportNamedDeclaration: {
                        prolog = false
                        break
                    }
                }
            }

            case Syntax.BlockStatement:
            case Syntax.ExpressionStatement: {
                switch (parent.type) {
                    case Syntax.IfStatement:
                    case Syntax.ForStatement:
                    case Syntax.ForOfStatement:
                    case Syntax.ForInStatement:
                    case Syntax.DoWhileStatement:
                    case Syntax.WhileStatement: {
                        prolog = false
                        break
                    }
                }
            }
        }

        // console.info(`*** prolog : ${prolog}`);
        if (prolog) {
            this.writeNewLine()
            this.writeIndend()
        }

        switch (statement.type) {
            case Syntax.BlockStatement: {
                this.visitBlockStatement(statement as Node.BlockStatement)
                break
            }
            case Syntax.ExpressionStatement: {
                this.visitExpressionStatement(statement as Node.ExpressionStatement)
                break
            }
            case Syntax.VariableDeclaration: {
                this.visitVariableDeclaration(statement as Node.VariableDeclaration)
                break
            }
            case Syntax.ClassDeclaration: {
                this.visitClassDeclaration(statement as Node.ClassDeclaration)
                break
            }
            case Syntax.LabeledStatement: {
                this.visitLabeledStatement(statement as Node.LabeledStatement)
                break
            }
            case Syntax.ReturnStatement: {
                this.visitReturnStatement(statement as Node.ReturnStatement)
                break
            }
            case Syntax.IfStatement: {
                this.visitIfStatement(statement as Node.IfStatement)
                break
            }
            case Syntax.FunctionDeclaration: {
                this.visitFunctionDeclaration(statement as Node.FunctionDeclaration)
                break
            }
            case Syntax.SwitchStatement: {
                this.visitSwitchStatement(statement as Node.SwitchStatement)
                break
            }
            case Syntax.BreakStatement: {
                this.visitBreakStatement(statement as Node.BreakStatement)
                break
            }
            case Syntax.EmptyStatement: {
                this.visitEmptyStatement(statement as Node.EmptyStatement)
                break
            }
            case Syntax.TryStatement: {
                this.visitTryStatement(statement as Node.TryStatement)
                break
            }
            case Syntax.ThrowStatement: {
                this.visitThrowStatement(statement as Node.ThrowStatement)
                break
            }
            case Syntax.WhileStatement: {
                this.visitWhileStatement(statement as Node.WhileStatement)
                break
            }
            case Syntax.DoWhileStatement: {
                this.visitDoWhileStatement(statement as Node.DoWhileStatement)
                break
            }
            case Syntax.ForOfStatement: {
                this.visitForOfStatement(statement as Node.ForOfStatement)
                break
            }
            case Syntax.ForInStatement: {
                this.visitForInStatement(statement as Node.ForInStatement)
                break
            }
            case Syntax.ForStatement: {
                this.visitForStatement(statement as Node.ForStatement)
                break
            }
            case Syntax.ContinueStatement: {
                this.visitContinueStatement(statement as Node.ContinueStatement)
                break
            }
            case Syntax.ExportNamedDeclaration: {
                this.visitExportNamedDeclaration(statement as Node.ExportNamedDeclaration)
                break
            }
            case Syntax.ExportDefaultDeclaration: {
                this.visitExportDefaultDeclaration(statement as Node.ExportDefaultDeclaration)
                break
            }
            case Syntax.ExportAllDeclaration: {
                this.visitExportAllDeclaration(statement as Node.ExportAllDeclaration)
                break
            }
            case Syntax.ImportDeclaration: {
                this.visitImportDeclaration(statement as Node.ImportDeclaration)
                break
            }
            case Syntax.SelectStatement: {
                this.visitSelectStatement(statement as Node.SelectStatement)
                break
            }
            case Syntax.DebuggerStatement: {
                this.visitDebuggerStatement(statement as Node.DebuggerStatement)
                break
            }
            default:
                throw new TypeError(`Type not handled : ${statement.type}`)
        }
    }

    visitExpression(expression: Node.Expression): void {
        switch (expression.type) {
            case Syntax.SequenceExpression: {
                this.visitSequenceExpression(expression as Node.SequenceExpression)
                break
            }
            case Syntax.Literal: {
                this.visitLiteral(expression as Node.Literal)
                break
            }
            case Syntax.Identifier: {
                this.visitIdentifier(expression as Node.Identifier)
                break
            }
            case Syntax.SpreadElement: {
                this.visitSpreadElement(expression as Node.SpreadElement)
                break
            }
            case Syntax.AssignmentExpression: {
                this.visitAssignmentExpression(expression as Node.AssignmentExpression)
                break
            }
            case Syntax.ObjectExpression: {
                this.visitObjectExpression(expression as Node.ObjectExpression)
                break
            }
            case Syntax.ArrayExpression: {
                this.visitArrayExpression(expression as Node.ArrayExpression)
                break
            }
            case Syntax.BinaryExpression: {
                this.visitBinaryExpression(expression as Node.BinaryExpression)
                break
            }
            case Syntax.LogicalExpression: {
                this.visitLogicalExpression(expression as Node.BinaryExpression)
                break
            }
            case Syntax.ClassExpression: {
                this.visitClassExpression(expression as Node.ClassExpression)
                break
            }
            case Syntax.ArrowFunctionExpression: {
                this.visitArrowFunctionExpression(expression as Node.ArrowFunctionExpression)
                break
            }
            case Syntax.FunctionExpression: {
                this.visitFunctionExpression(expression as Node.FunctionExpression)
                break
            }
            case Syntax.CallExpression: {
                this.visitCallExpression(expression as Node.CallExpression)
                break
            }
            case Syntax.OptionalCallExpression: {
                this.visitOptionalCallExpression(expression as Node.OptionalCallExpression)
                break
            }
            case Syntax.MemberExpression: {
                this.visitMemberExpression(expression as Node.StaticMemberExpression | Node.ComputedMemberExpression)
                break
            }
            case Syntax.ThisExpression: {
                this.visitThisExpression(expression as Node.ThisExpression)
                break
            }
            case Syntax.UpdateExpression: {
                this.visitUpdateExpression(expression as Node.UpdateExpression)
                break
            }
            case Syntax.UnaryExpression: {
                this.visitUnaryExpression(expression as Node.UnaryExpression)
                break
            }
            case Syntax.NewExpression: {
                this.visitNewExpression(expression as Node.NewExpression)
                break
            }
            case Syntax.VariableDeclaration: {
                this.visitVariableDeclaration(expression as Node.VariableDeclaration)
                break
            }
            case Syntax.Property: {
                this.visitProperty(expression as Node.Property)
                break
            }
            case Syntax.ArrayPattern: {
                this.visitArrayPattern(expression as Node.ArrayPattern)
                break
            }
            case Syntax.ObjectPattern: {
                this.visitObjectPattern(expression as Node.ObjectPattern)
                break
            }
            case Syntax.AwaitExpression: {
                this.visitAwaitExpression(expression as Node.AwaitExpression)
                break
            }
            case Syntax.ConditionalExpression: {
                this.visitConditionalExpression(expression as Node.ConditionalExpression)
                break
            }
            case Syntax.AssignmentPattern: {
                this.visitAssignmentPattern(expression as Node.AssignmentPattern)
                break
            }
            case Syntax.Super: {
                this.visitSuper(expression as Node.Super)
                break
            }
            case Syntax.RestElement: {
                this.visitRestElement(expression as Node.RestElement)
                break
            }
            case Syntax.YieldExpression: {
                this.visitYieldExpression(expression as Node.YieldExpression)
                break
            }
            case Syntax.MetaProperty: {
                this.visitMetaProperty(expression as Node.MetaProperty)
                break
            }
            case Syntax.OptionalMemberExpression: {
                this.visitOptionalMemberExpression(expression as Node.OptionalMemberExpression)
                break
            }
            case Syntax.TemplateLiteral: {
                this.visitTemplateLiteral(expression as Node.TemplateLiteral)
                break
            }
            case Syntax.TaggedTemplateExpression: {
                this.visitTaggedTemplateExpression(expression as Node.TaggedTemplateExpression)
                break
            }
            case Syntax.QueryExpression: {
                this.visitQueryExpression(expression as Node.QueryExpression)
                break
            }
            default:
                throw new TypeError("Type not handled : " + expression.type)
        }
    }

    visitTaggedTemplateExpression(expression: Node.TaggedTemplateExpression): void {
        this.assertNotNull(expression)
        this.visitExpression(expression.tag)
        this.visitTemplateLiteral(expression.quasi)
    }

    visitDebuggerStatement(statement: Node.DebuggerStatement): void {
        this.assertNotNull(statement)
        this.write("debugger ", false)
    }

    visitContinueStatement(statement: Node.ContinueStatement): void {
        this.assertNotNull(statement)
        this.write("continue ", false)

        if (statement.label) {
            this.write(" ", false)
            this.visitIdentifier(statement.label)
        }
    }

    visitImportDeclaration(statement: Node.ImportDeclaration): void {
        this.assertNotNull(statement)
        this.write("import ", false)

        if (statement.specifiers && statement.specifiers.length > 0) {
            const specifiers: Node.ImportDeclarationSpecifier[] = statement.specifiers
            let hasImportSpec = false
            for (let i = 0; i < specifiers.length; ++i) {
                const specifier = specifiers[i]
                if (specifier.type === Syntax.ImportDefaultSpecifier) {
                    if (specifier.local) {
                        this.visitIdentifier(specifier.local)
                        this.write(" ", false)
                    }
                } else if (specifier.type === Syntax.ImportSpecifier) {
                    const is = specifier as Node.ImportSpecifier
                    this.writeConditional(!hasImportSpec, "{", false)

                    if (is.local != null && is.imported) {
                        this.visitIdentifier(is.imported)
                        this.write(" as ", false)
                        this.visitIdentifier(is.local)
                    } else {
                        this.visitIdentifier(is.imported)
                    }

                    hasImportSpec = true
                } else if (specifier.type === Syntax.ImportNamespaceSpecifier) {
                    this.write("*", false)
                    this.write(" as ", false)
                    this.visitIdentifier(specifier.local)
                    this.write(" ", false)
                } else {
                    throw new TypeError("Unhandled type")
                }

                this.writeConditional(i < specifiers.length - 1, ", ", false)
            }

            this.writeConditional(hasImportSpec, "} ", false)
            this.write("from ", false)
        }

        this.visitLiteral(statement.source)
    }

    visitExportAllDeclaration(statement: Node.ExportAllDeclaration) {
        this.write("export * ", false)
        this.write("from ", false)

        this.visitLiteral(statement.source)
    }

    visitExportDefaultDeclaration(statement: Node.ExportDefaultDeclaration) {
        this.write("export default ", false)

        switch (statement.declaration.type) {
            case Syntax.FunctionDeclaration:
                this.visitFunctionDeclaration(statement.declaration as Node.FunctionDeclaration)
                break
            default:
                this.visitExpression(statement.declaration)
        }
    }

    visitExportNamedDeclaration(statement: Node.ExportNamedDeclaration) {
        this.write("export", false)
        this.write(" ", false)

        if (statement.declaration) {
            this.visitStatement(statement.declaration)
        } else if (statement.specifiers && statement.specifiers.length > 0) {
            this.write("{", false)
            const specifiers: Node.ExportSpecifier[] = statement.specifiers
            for (let i = 0; i < specifiers.length; ++i) {
                const specifier: Node.ExportSpecifier = specifiers[i]
                this.visitIdentifier(specifier.local)

                if (specifier.exported) {
                    this.write(" as ", false)
                    this.visitIdentifier(specifier.exported)
                }
                this.write(i < specifiers.length - 1 ? " ," : "", false)
            }
            this.write("}", false)
        } else {
            throw new Error("No 'export's to emit")
        }

        if (statement.source) {
            this.write(" ", false)
            this.write("from", false)
            this.write(" ", false)
            this.visitLiteral(statement.source)
        }
    }

    visitForStatement(statement: Node.ForStatement): void {
        this.write("for", false)
        this.write("(", false)

        if (statement.init) {
            this.visitExpression(statement.init)
        }
        this.write(";", false)

        if (statement.test) {
            this.visitExpression(statement.test)
        }
        this.write(";", false)

        if (statement.update) {
            this.visitExpression(statement.update)
        }

        this.write(")", false)
        this.write(" ", false)

        this.visitStatement(statement.body)
    }

    visitForOfStatement(statement: Node.ForOfStatement) {
        this.write("for", false)
        this.writeConditional(statement.await, " await ", false)
        this.write("(", false)
        this.visitExpression(statement.left)
        this.write(" of ", false)
        this.visitExpression(statement.right)
        this.write(")", false)
        this.write(" ", false)

        this.visitStatement(statement.body)
    }

    visitForInStatement(statement: Node.ForInStatement) {
        this.write("for", false)
        this.write("(", false)
        this.visitExpression(statement.left)
        this.write(" in ", false)
        this.visitExpression(statement.right)
        this.write(")", false)
        this.write(" ", false)

        this.visitStatement(statement.body)
    }

    visitDoWhileStatement(statement: Node.DoWhileStatement) {
        this.write("do", false)
        this.write(" ", false)

        this.visitStatement(statement.body)
        this.write(" ", false)
        this.write("while", false)
        this.write(" ", false)
        this.write("(", false)
        this.visitExpression(statement.test)
        this.write(")", false)
    }

    visitWhileStatement(statement: Node.WhileStatement): void {
        this.write("while", false)
        this.write(" ", false)
        this.write("(", false)
        this.visitExpression(statement.test)
        this.write(")", false)
        this.write(" ", false)

        this.visitStatement(statement.body)
    }

    visitThrowStatement(statement: Node.ThrowStatement): void {
        this.write("throw", false)
        this.write(" ", false)
        this.visitExpression(statement.argument)
    }

    visitTryStatement(statement: Node.TryStatement): void {
        this.write("try", false)
        this.write(" ", false)

        this.visitBlockStatement(statement.block)

        if (statement.handler) {
            this.writeNewLine()
            this.visitCatchClause(statement.handler)
        }

        if (statement.finalizer) {
            this.writeNewLine()
            this.write("finally", false)
            this.write(" ", false)

            this.visitBlockStatement(statement.finalizer)
        }
    }

    visitCatchClause(clause: Node.CatchClause): void {
        this.write("catch", false)
        if (clause.param) {
            this.write(" ", false)
            this.write("(", false)
            this.visitBinding(clause.param as Binding)
            this.write(")", false)
        }

        this.write(" ", false)
        this.visitBlockStatement(clause.body)
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    visitEmptyStatement(statement: Node.EmptyStatement): void {
        this.write(";", false)
    }

    visitBreakStatement(statement: Node.BreakStatement): void {
        this.write("break", false)
        if (statement.label) {
            this.write(" ", false)
            this.visitIdentifier(statement.label)
        }
    }

    visitSwitchStatement(statement: Node.SwitchStatement): void {
        this.write("switch", false)
        this.write(" ", false)
        this.write("(", false)
        this.visitExpression(statement.discriminant)
        this.write(")", false)
        this.write(" ", false)

        this.builder.push({flatGroup: true})
        this.write("{", false)
        this.writeNewLine()

        if (statement.cases) {
            for (let i = 0; i < statement.cases.length; ++i) {
                this.writeIndend()
                this.visitSwitchCase(statement.cases[i])
                if (i < statement.cases.length - 1) {
                    this.writeNewLine()
                }
            }
        }
        this.write("}", false)
        this.builder.pop()
    }

    visitSwitchCase(_case: Node.SwitchCase) {
        const isDefault = _case.test == null

        if (isDefault) {
            this.write("default : ", false)
        } else {
            this.write("case", false)
            this.write(" ", false)
            if (_case.test != null) {
                this.visitExpression(_case.test)
            }
            this.write(" :", false)
        }

        // FIXME: push/pop groups need to be reworked
        // FIXME : Formatting for following cased is borked, syntatically this is correct but visually it is not very pleasing

        /*
    // # 1     
    switch (type) {
        case 1: {
        }
    }

    // # 2     
    switch (type) {
        case 1: {
        }
        {}
    }
    */

        if (_case.consequent.length > 0) {
            this.builder.push({flatGroup: true})
            this.write("", false)
            for (const statement of _case.consequent) {
                this.visitStatement(statement)
            }
            this.write("", false)
            this.builder.pop()
        }
    }

    visitIfStatementConsequent(node: Node.Statement) {
        if (node.type === Syntax.ExpressionStatement) {
            this.visitExpressionStatement(node as Node.ExpressionStatement)
        } else {
            this.visitStatement(node)
        }
    }

    /**
     * Non blocked if statement are not properly rendering
     *
     * Example:
     * ```
     *
     * ```
     * @param node
     */
    visitIfStatement(node: Node.IfStatement) {
        this.write("if", false)
        this.write(" ", false)
        this.write("(", false)
        this.visitExpression(node.test)
        this.write(")", false)
        this.write(" ", false)

        node.consequent.__name__ = "consequent"

        this.visitIfStatementConsequent(node.consequent)

        // Check for nested IfStatement and render them differently
        if (node.alternate) {
            this.writeNewLine()
            this.write("else ", false)
            node.alternate.__name__ = "alternate"
            this.visitIfStatementConsequent(node.alternate)
        }
    }

    visitUpdateExpression(expression: Node.UpdateExpression): void {
        const parens = hasParenthesis(expression.argument, "argument")
        this.writeConditional(parens, "(", false)

        this.writeConditional(expression.prefix, expression.operator, false)
        this.visitExpression(expression.argument)
        this.writeConditional(!expression.prefix, expression.operator, false)

        this.writeConditional(parens, ")", false)
    }

    visitReturnStatement(expression: Node.ReturnStatement): void {
        this.write("return", false)

        if (expression.argument != null) {
            this.write(" ", false)
            this.visitExpression(expression.argument)
        }
    }

    visitLabeledStatement(expression: Node.LabeledStatement) {
        this.visitIdentifier(expression.label)
        this.write(":", false)
        if (expression.body) {
            this.visitStatement(expression.body)
        }
    }

    visitClassDeclaration(expression: Node.ClassDeclaration): void {
        this.classDefinition(expression)
    }

    visitClassExpression(expression: Node.ClassExpression): void {
        this.write("(", false)
        this.classDefinition(expression)
        this.write(")", false)
    }

    classDefinition(expression: Node.ClassDeclaration | Node.ClassExpression) {
        this.assertNotNull(expression)

        this.write("class ", false)
        if (expression.id != null) {
            this.visitIdentifier(expression.id as Node.Identifier)
            this.write(" ", false)
        }

        if (expression.superClass) {
            this.write("extends ", false)
            const parens = hasParenthesis(expression.superClass, "superClass")
            this.writeConditional(parens, "(", false)
            this.visitExpression(expression.superClass)
            this.writeConditional(parens, ")", false)
        }

        this.builder.push({flatGroup: true})
        this.write("{", false)
        const clzBody: Node.ClassBody = expression.body

        for (let i = 0; i < clzBody.body.length; i++) {
            this.writeNewLine()
            this.writeIndend()

            const property:
                | Node.MethodDefinition
                | Node.EmptyStatement
                | Node.ClassPrivateProperty
                | Node.ClassProperty = clzBody.body[i]

            switch (property.type) {
                case Syntax.EmptyStatement: {
                    this.visitEmptyStatement(property as Node.EmptyStatement)
                    break
                }
                case Syntax.MethodDefinition: {
                    this.visitMethodDefinition(property as Node.MethodDefinition)
                    break
                }
                case Syntax.ClassPrivateProperty: {
                    this.visitClassPrivateProperty(property as Node.ClassPrivateProperty)
                    break
                }
                case Syntax.ClassProperty: {
                    this.visitClassProperty(property as Node.ClassProperty)
                    break
                }

                default:
                    throw new TypeError("Type not handled  : " + property.type)
            }
        }

        this.write("}", false)
        this.builder.pop()
    }

    visitClassPrivateProperty(property: Node.ClassPrivateProperty) {
        this.write("#", false)
        this.visitClassProperty(property as Node.ClassProperty)
    }

    visitClassProperty(property: Node.ClassProperty) {
        this.visitPropertyKey(property.id)
        this.write(" = ", false)
        this.visitExpression(property.expression)
    }

    visitMethodDefinition(expression: Node.MethodDefinition) {
        this.assertNotNull(expression)

        if (expression.value) {
            if (expression.value.type == Syntax.FunctionExpression) {
                if (expression.static) {
                    this.write("static", false)
                    this.write(" ", false)
                }

                if (expression.value.async) {
                    this.write("async", false)
                    this.write(" ", false)
                }

                if (expression.value.generator) {
                    this.write("*", false)
                }
            }
        }

        if (expression.kind === "get" || expression.kind === "set") {
            this.write(expression.kind, false)
            this.write(" ", false)
        }

        if (expression.key != null) {
            this.writeConditional(expression.computed, "[", false)
            this.visitPropertyKey(expression.key)
            this.writeConditional(expression.computed, "]", false)
        }

        if (expression.value) {
            if (expression.value.type == Syntax.FunctionExpression) {
                const value: Node.FunctionExpression = expression.value
                this.visitFunctionParameterArray(value.params)
                this.write(" ", false)
                this.visitBlockStatement(value.body)
            } else {
                throw new TypeError("Unknow type")
            }
        }
    }

    visitBlockStatement(statement: Node.BlockStatement): void {
        this.assertNotNull(statement)
        // how do we want to group this block statement
        let flat = true
        if (Array.isArray(statement.__parent__)) {
            flat = false
        }

        this.builder.push({flatGroup: flat})
        this.write("{", false)
        const body = statement.body
        if (body != null) {
            for (let i = 0; i < body.length; ++i) {
                this.visitStatement(body[i])
            }
        }

        this.write("}", false)
        this.builder.pop()
    }

    visitExpressionStatement(statement: Node.ExpressionStatement): void {
        const parens = hasParenthesis(statement.expression, "expression")

        this.writeConditional(parens, "(", false)
        this.visitExpression(statement.expression)
        this.writeConditional(parens, ")", false)
    }

    visitAssignmentExpression(expression: Node.AssignmentExpression): void {
        this.visitExpression(expression.left)
        this.write(" ", false)
        this.write(expression.operator, false)
        this.write(" ", false)
        this.visitExpression(expression.right)
    }

    visitSequenceExpression(sequence: Node.SequenceExpression): void {
        // FIXME : Need to find rules for when to output `;`
        if (
            false &&
            sequence.__parent__.type !== Syntax.SequenceExpression
            // sequence.__parent__.type !== Syntax.ExpressionStatement
        ) {
            this.write(";", false)
        }

        if (sequence.expressions.length > 1) {
            this.write("(", false)
        }

        for (let i = 0; i < sequence.expressions.length; ++i) {
            const parens = hasParenthesis(sequence.expressions[i])

            this.writeConditional(parens, "(", false)
            this.visitExpression(sequence.expressions[i] as Node.Expression)
            this.writeConditional(parens, ")", false)

            if (i < sequence.expressions.length - 1) {
                this.write(", ", false)
            }
        }

        if (sequence.expressions.length > 1) {
            this.write(")", false)
        }
    }

    visitTemplateLiteral(template: Node.TemplateLiteral): void {
        if (template.quasis.length === 0) {
            this.write("``", false)
        } else {
            this.write("`", false)
            for (let i = 0; i < template.quasis.length; ++i) {
                const quasi = template.quasis[i]
                this.write(quasi.value.raw, false)
                if (i < template.expressions.length) {
                    this.write("${", false)
                    this.visitExpression(template.expressions[i])
                    this.write("}", false)
                }
            }
            this.write("`", false)
        }
    }

    visitMetaProperty(expression: Node.MetaProperty): void {
        this.visitIdentifier(expression.meta)
        this.write(".", false)
        this.visitIdentifier(expression.property)
    }

    visitYieldExpression(expression: Node.YieldExpression): void {
        this.write("yield", false)

        if (expression.delegate) {
            this.write("*", false)
        }

        if (expression.argument) {
            this.write(" ", false)
            this.visitExpression(expression.argument)
        }
    }

    visitSuper(expression: Node.Super) {
        this.write("super", false)
    }

    visitConditionalExpression(expression: Node.ConditionalExpression): void {
        this.visitExpression(expression.test)
        this.write(" ? ", false)
        this.visitExpression(expression.consequent)
        this.write(" : ", false)
        this.visitExpression(expression.alternate)
    }

    visitAwaitExpression(expression: Node.AwaitExpression) {
        this.write("await", false)
        this.write(" ", false)
        this.visitExpression(expression.argument)
    }

    visitProperty(expression: Node.Property): void {
        const key = expression.key
        const value = expression.value
        if (expression.shorthand) {
            // ({c=z}) => 0 // shorthand
            // ({c}) => 0 // shorthand
            if (value instanceof Node.AssignmentPattern) {
                this.visitAssignmentPattern(value)
            } else {
                this.visitExpression(key)
            }
        } else {
            this.writeConditional(expression.computed, "[", false)
            this.visitExpression(key)
            this.writeConditional(expression.computed, "]", false)

            if (value) {
                this.write(" : ", false)
                this.visitExpression(value)
            }
        }
    }

    visitUnaryExpression(expression: Node.UnaryExpression): void {
        const parens = hasParenthesis(expression.argument, "argument")

        this.write(expression.operator, false)
        this.writeConditional(parens, "(", false)
        this.writeConditional(expression.operator === "typeof" || expression.operator === "void", " ", false)
        this.visitExpression(expression.argument)
        this.writeConditional(parens, ")", false)
    }

    visitNewExpression(expression: Node.NewExpression): void {
        const callee = expression.callee
        const args = expression.arguments

        this.write("new ", false)
        this.visitExpression(callee)
        this.visitParams(args)
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    visitThisExpression(expression: Node.ThisExpression) {
        this.write("this", false)
    }

    visitOptionalCallExpression(expression: Node.OptionalCallExpression) {
        this._visitCallExpression(expression)
    }

    visitCallExpression(expression: Node.CallExpression) {
        this._visitCallExpression(expression)
    }

    private _visitCallExpression(expression: Node.CallExpression | Node.OptionalCallExpression) {
        const args = expression.arguments
        if (
            expression.callee.type === Syntax.FunctionExpression ||
            expression.callee.type === Syntax.ArrowFunctionExpression
        ) {
            this.write("(", false)

            if (expression.callee.type === Syntax.FunctionExpression) {
                this.visitFunctionExpression(expression.callee as Node.FunctionExpression)
            } else if (expression.callee.type === Syntax.ArrowFunctionExpression) {
                this.visitArrowFunctionExpression(expression.callee as Node.ArrowFunctionExpression)
            } else {
                throw new TypeError(`Type not handled  '${expression.callee.type}'`)
            }

            this.write(")", false)
            this.visitParams(args)
        } else if (expression.callee.type == Syntax.Import) {
            this.write("import", false)
            this.visitParams(args)
        } else {
            this.visitExpression(expression.callee)
            this.visitParams(args)
        }
    }

    visitMemberExpression(
        expression: Node.StaticMemberExpression | Node.ComputedMemberExpression | Node.OptionalMemberExpression
    ) {
        if (expression instanceof Node.StaticMemberExpression || expression instanceof Node.OptionalMemberExpression) {
            const isOptional = expression instanceof Node.OptionalMemberExpression
            this.visitExpression(expression.object)
            this.write(isOptional ? "?." : ".", false)
            this.visitExpression(expression.property)
        } else if (expression instanceof Node.ComputedMemberExpression) {
            this.visitExpression(expression.object)
            this.write("[", false)
            this.visitExpression(expression.property)
            this.write("]", false)
        } else {
            throw new TypeError("Unhandled type : " + expression)
        }
    }

    visitOptionalMemberExpression(expression: Node.OptionalMemberExpression) {
        this.visitMemberExpression(expression)
    }

    visitParams(args: Node.ArgumentListElement[] | Node.FunctionParameter[]) {
        this.write("(", false)
        for (let i = 0; i < args.length; ++i) {
            const arg = args[i]
            if (arg instanceof Node.RestElement) {
                this.visitRestElement(arg as Node.RestElement)
            } else {
                this.visitExpression(arg as Node.Expression)
            }
            this.write(i < args.length - 1 ? ", " : "", false)
        }
        this.write(")", false)
    }

    visitFunctionDeclaration(expression: Node.FunctionDeclaration): void {
        if (expression.async) {
            this.write(" async ", false)
        }

        this.write("function", false)

        if (expression.generator) {
            this.write("*", false)
        }

        this.write(" ", false)

        if (expression.id != null) {
            this.visitIdentifier(expression.id)
        }

        this.visitParams(expression.params)
        this.write(" ", false)
        this.visitBlockStatement(expression.body)
    }

    visitBinaryExpression(expression: Node.BinaryExpression): void {
        this.binaryExpression(expression)
    }

    visitLogicalExpression(expression: Node.BinaryExpression): void {
        this.binaryExpression(expression)
    }

    binaryExpression(expression: Node.BinaryExpression): void {
        const leftParen = hasParenthesis(expression.left, "left")
        const rightParen = hasParenthesis(expression.right, "right")

        this.writeConditional(leftParen, "(", false)
        this.visitExpression(expression.left)
        this.writeConditional(leftParen, ")", false)

        this.write(` ${expression.operator} `, false)

        this.writeConditional(rightParen, "(", false)
        this.visitExpression(expression.right)
        this.writeConditional(rightParen, ")", false)
    }

    visitArrayExpression(expression: Node.ArrayExpression): void {
        const elements: Node.ArrayExpressionElement[] = expression.elements
        this.write("[", false)
        for (let i = 0; i < elements.length; ++i) {
            const element: Node.ArrayExpressionElement = elements[i] //  Expression | SpreadElement | null;
            if (element == null) {
                // this.write('null', false)//
                this.write(" ", false) //
            } else if (element instanceof Node.RestElement) {
                this.visitRestElement(element as Node.RestElement)
            } else {
                this.visitExpression(element as Node.Expression)
            }
            this.write(i < elements.length - 1 ? ", " : "", false)
        }
        this.write("]", false)
    }

    visitSpreadElement(expression: Node.SpreadElement): void {
        const wrap = hasParenthesis(expression.argument, "argument")
        this.write("...", false)
        this.writeConditional(wrap, "(", false)
        this.visitExpression(expression.argument)
        this.writeConditional(wrap, ")", false)
    }

    visitRestElement(expression: Node.RestElement): void {
        this.write("...", false)
        this.visitExpression(expression.argument)
    }

    visitObjectExpression(expression: Node.ObjectExpression): void {
        const properties: Node.ObjectExpressionProperty[] = expression.properties
        if (expression.properties.length === 0) {
            this.write("{}", false)
        } else {
            this.write("{", false)
            for (let i = 0; i < properties.length; ++i) {
                this.visitObjectExpressionProperty(properties[i])
                this.write(i < properties.length - 1 ? ", " : "", false)
            }
            this.write("}", false)
        }
    }

    visitObjectExpressionProperty(expression: Node.ObjectExpressionProperty): void {
        switch (expression.type) {
            case Syntax.Property: {
                const property = expression as Node.Property
                const key: Node.PropertyKey = property.key
                const value: Node.PropertyValue | null = property.value

                if (
                    (property.method && property.kind === "init") ||
                    property.kind === "get" ||
                    property.kind === "set"
                ) {
                    const method = new Node.MethodDefinition(
                        key,
                        property.computed,
                        value as Node.FunctionExpression,
                        property.kind,
                        false
                    )
                    this.visitMethodDefinition(method)
                } else {
                    if (property.shorthand) {
                        this.visitPropertyKey(key)
                    } else {
                        this.write(property.computed ? "[" : "", false)
                        this.visitPropertyKey(key)
                        this.write(property.computed ? "]" : "", false)
                        this.write(":", false)
                        this.visitPropertyValue(value)
                    }
                }
                break
            }
            case Syntax.SpreadElement: {
                const property = expression as Node.SpreadElement
                this.write("...", false)
                this.visitExpression(property.argument)
                break
            }
            default:
                throw new TypeError(`Type not handled  '${expression.type}'`)
        }
    }

    visitPropertyValue(value: Node.PropertyValue) {
        //AssignmentPattern | AsyncFunctionExpression | BindingIdentifier | BindingPattern | FunctionExpression;
        switch (value.type) {
            case Syntax.AssignmentPattern: {
                this.visitAssignmentPattern(value as Node.AssignmentPattern)
                break
            }
            case Syntax.Literal: {
                this.visitLiteral(value as Node.Literal)
                break
            }
            case Syntax.Identifier: {
                this.visitIdentifier(value as Node.Identifier)
                break
            }
            case Syntax.ArrayPattern: {
                this.visitArrayPattern(value as Node.ArrayPattern)
                break
            }
            case Syntax.ObjectPattern: {
                this.visitObjectPattern(value as Node.ObjectPattern)
                break
            }
            case Syntax.FunctionExpression:
            case Syntax.ArrowFunctionExpression:
            case Syntax.ObjectExpression:
            case Syntax.ArrayExpression:
            case Syntax.BinaryExpression:
            case Syntax.LogicalExpression:
            case Syntax.UnaryExpression:
            case Syntax.MemberExpression: {
                this.visitExpression(value)
                break
            }
            default:
                throw new TypeError("Type not handled : " + value.type)
        }
    }

    visitFunctionParameterArray(params: Node.FunctionParameter[]): void {
        this.write("(", false)
        for (let i = 0; i < params.length; ++i) {
            this.visitFunctionParameter(params[i])
            this.write(i < params.length - 1 ? ", " : "", false)
        }
        this.write(")", false)
    }

    visitFunctionExpression(expression: Node.FunctionExpression): void {
        if (expression.async) {
            this.write("async", false)
            this.write(" ", false)
        }

        this.write("function", false)

        if (expression.generator) {
            this.write("*", false)
        }

        this.write(" ", false)

        if (expression.id != null) {
            this.visitIdentifier(expression.id)
        }

        this.visitParams(expression.params)
        this.write(" ", false)
        this.visitBlockStatement(expression.body)
    }

    visitArrowFunctionExpression(expression: Node.ArrowFunctionExpression): void {
        if (expression.async) {
            this.write("async", false)
            this.write(" ", false)
        }

        this.visitFunctionParameterArray(expression.params)
        this.write(" ", false)
        this.write("=>", false)
        this.write(" ", false)

        if (expression.body instanceof Node.BlockStatement) {
            this.visitBlockStatement(expression.body)
        } else {
            const parens = hasParenthesis(expression.body, "body")
            this.writeConditional(parens, "(", false)
            this.visitExpression(expression.body)
            this.writeConditional(parens, ")", false)
        }
    }

    visitFunctionParameter(param: Node.FunctionParameter): void {
        switch (param.type) {
            case Syntax.AssignmentPattern: {
                this.visitAssignmentPattern(param as Node.AssignmentPattern)
                break
            }
            case Syntax.Identifier: {
                this.visitIdentifier(param as Node.Identifier)
                break
            }
            case Syntax.ArrayPattern: {
                this.visitArrayPattern(param as Node.ArrayPattern)
                break
            }
            case Syntax.ObjectPattern: {
                this.visitObjectPattern(param as Node.ObjectPattern)
                break
            }
            case Syntax.RestElement: {
                this.visitRestElement(param as Node.RestElement)
                break
            }
            default:
                throw new TypeError("Type not handled : " + param.type)
        }
    }

    visitAssignmentPattern(expression: Node.AssignmentPattern): void {
        this.visitBinding(expression.left as Binding)
        this.write(" = ", false)
        this.visitExpression(expression.right)
    }

    visitBinding(binding: Binding) {
        if (binding == undefined) {
            return
        }

        if (binding instanceof Node.Identifier) {
            this.visitIdentifier(binding as Node.Identifier)
        } else if (binding instanceof Node.ArrayPattern) {
            this.visitArrayPattern(binding as Node.ArrayPattern)
        } else if (binding instanceof Node.ObjectPattern) {
            this.visitObjectPattern(binding as Node.ObjectPattern)
        } else {
            throw new TypeError("Type not handled")
        }
    }

    visitObjectPattern(node: Node.ObjectPattern): void {
        this.write("{", false)
        const elements = node.properties
        for (let i = 0; i < elements.length; ++i) {
            const pattern: Node.ObjectPatternProperty = elements[i]
            if (pattern) {
                this.visitExpression(pattern)
            }
            this.writeConditional(i < elements.length - 1, ", ", false)
        }
        this.write("}", false)
    }

    visitArrayPattern(node: Node.ArrayPattern): void {
        this.write("[", false)
        const elements = node.elements
        for (let i = 0; i < elements.length; ++i) {
            const pattern: Node.ArrayPatternElement = elements[i]
            if (pattern) {
                this.visitExpression(pattern)
            } else {
                this.write(", ", false)
                continue
            }
            this.writeConditional(i < elements.length - 1, ", ", false)
        }
        this.write("]", false)
    }

    visitPropertyKey(key: Node.PropertyKey) {
        if (key instanceof Node.Identifier) {
            this.visitIdentifier(key as Node.Identifier)
        } else if (key instanceof Node.Literal) {
            this.visitLiteral(key as Node.Literal)
        } else if (key instanceof Node.BinaryExpression) {
            this.visitBinaryExpression(key as Node.BinaryExpression)
        } else if (key instanceof Node.StaticMemberExpression) {
            this.visitMemberExpression(key as Node.StaticMemberExpression)
        } else {
            throw new TypeError("Not implemented : " + key.constructor)
        }
    }

    visitLiteral(literal: Node.Literal): void {
        this.write(literal.raw, false)
    }

    visitIdentifier(identifier: Node.Identifier): void {
        this.write(identifier.name, false)
    }

    visitVariableDeclaration(declaration: Node.VariableDeclaration): void {
        const kind = declaration.kind
        const declarations = declaration.declarations
        this.write(`${kind} `, false)
        for (let i = 0; i < declarations.length; ++i) {
            this.visitVariableDeclarator(declarations[i] as Node.VariableDeclarator)
            this.writeConditional(i < declarations.length - 1, ", ", false)
        }
    }

    visitVariableDeclarator(declarator: Node.VariableDeclarator) {
        const ident = declarator.id as Binding
        const init = declarator.init as Node.Expression | null
        if (ident != null) {
            this.visitBinding(ident)
        }

        if (init != null) {
            this.write(" = ", false)
            this.visitExpression(init)
        }
    }

    visitSelectStatement(statement: Node.SelectStatement): void {
        this.assertNotNull(statement)
        this.visitQueryExpression(statement.body)
    }

    visitQueryExpression(expression: Node.QueryExpression): void {
        this.assertNotNull(expression)
        const body: Node.QueryExpression = expression
        const from = body.from
        const select = body.select
        const where = body.where

        // console.info(from)
        // console.info(select)
        // console.info(where)

        this.write("Select", false)
        this.write("([ ", false)

        for (let i = 0; i < select.projections.length; ++i) {
            const projection = select.projections[i]
            const expression = projection.expression

            //   this.writeNewLine();
            this.write("{expr: ", false)
            this.visitExpression(expression)

            if (projection.alias) {
                this.write(", alias: ", false)
                this.visitExpression(projection.alias)
            }

            this.write("}", false)
            this.writeConditional(i < select.projections.length - 1, ", ", false)
            //   this.writeNewLine();
        }

        this.write("]", false)
        this.write(")", false)

        if (from) {
            this.writeNewLine()

            const fce: Node.FromClauseElement = from.expressions[0]
            const exp = fce.expression

            console.info(exp)
            console.info(from.expressions[0])

            this.write(".From", false)
            this.write("(", false)
            if (exp.type === Syntax.URIIdentifier) {
                this.write(`URIDataSource.of('${exp.uri}')`, false)
            } else if (exp.type === Syntax.CallExpression) {
                this.visitCallExpression(exp as Node.CallExpression)
            } else {
                throw new TypeError(`From source not handled : ${exp.type}`)
            }
            this.write(")", false)
        }

        if (where) {
            this.writeNewLine()

            this.write(".Where", false)
            this.write("((row)=> {", false)
            this.write("return (", false)
            this.visitExpression(where.expression)
            this.write(")", false)
            this.write("})", false)
        }
    }

    /**
     * Asserts that a object is not null
     *
     * @param obj
     * @param message
     */
    private assertNotNull(obj: any, message = "Assertion failed"): void {
        if (isNullOrUndefined(obj)) {
            throw new TypeError(message)
        }
    }
}
